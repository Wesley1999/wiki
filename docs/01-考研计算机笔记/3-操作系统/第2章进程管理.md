# 第2章进程管理

## 进程与线程

### 程序概念

程序是静态的，是存放在磁盘里的可执行文件，是一系列的指令集合。

提高单机资源利用率的关键技术是多道程序设计及技术。

并发性（多道程序技术）的实现需要需要中断功能的支持。

### 进程的概念与特征

进程是程序的一次执行过程。

程序段、数据段、进程控制块（PCB）构成进程映像。

同一程序的多个进程，程序段相同，PCB、数据段不同。

### 进程状态

1. 创建态
2. 就绪态
3. 运行态
4. 结束态（终止态）
5. 阻塞态

单核CPU最多只会有一个进程处于运行态。

运行态到阻塞态是主动行为，阻塞态到就绪态是被动行为。

当有多个进程等待同一个资源时，资源被释放后，仅唤醒等待队列中的第一个进程



不可能出现有进程就绪而没有进程运行的情况。

磁盘速度很慢，只要读/写磁盘，就要等待I/O操作，进程会阻塞。

### 进程控制

进程控制用的程序段是**原语**，原语执行期间不允许中断（原子性），这个性质是通过关中断实现的。关中断指令不允许普通程序使用。

### 进程的通信

#### 共享存储

需要使用互斥工具（PV）

#### 消息传递

直接通信方式

间接通信方式（电子邮件就是间接通信方式）

#### 管道通信

管道的本质是存于**内存**中的文件，通常容量为内存上的一页。

从管道中读数据时一次性操作，数据一旦读出，它就从管道中被抛弃。

读进程只能有一个，写进程可以有多个。

管道只能采用半双工方式，及某一时刻只能单向传输。

管道满时，写会阻塞；管道空时，读会阻塞。



### 线程概念

切换进程需要保存/恢复进程运行环境，还需要切换内存地址空间（更新快表、更新缓存），开销很大，所以要引入线程。

线程本身不具有任何资源，线程共享进程的资源。

同一进程切换线程开销很小。

同一进程的线程通信不需要操作系统的干涉。



进程是资源分配的单位，线程是处理器调度和分派的单位。



线程可分为用户级线程、内核级线程。

用户级线程的优先是开销小、效率高，缺点是不能处理阻塞，只能在一个CPU上运行

内核级线程的优先是并发能力强，能处理阻塞，缺点是线程的切换需要在核心态完成，开销大。



多对一模型相当于用户级线程。

多对多模型中，所有内核级线程都被阻塞时，进程才会阻塞。



同一个系统的进程（或线程），可以由系统调用的方法被不同进程（或线程）使用。



线程间栈指针不能共享。

### 作业概念

作业是存放在外存中还没有投入运行的程序。

作业由用户提交，一用户任务为单位；进程由系统生成，是操作系统的资源分配和独立运行的基本单位。



## 处理机调度

### 调度的层次

作业调度（高级调度）：为进程活动做准备，频率低

内存调度（中级调度）：将暂时不能运行的进程挂起，处于作业调度和进程调度之间，频率略高

进程调度（低级调度）：使进程正常活动起来，频率最高



进程调度是最基本的，不可或缺。



### 调度方式

非剥夺调度方式（非抢占方式）：当前正在执行的进程完成或阻塞后，才把处理机分配给更重要的进程

剥夺调度方式（抢占方式）：将处理机分配给更重要的进程

### 调度的基本准则

CPU利用率

系统吞吐量

周转时间

等待时间

响应时间

### 调度算法

#### 先来先服务调度算法（FCFS）

简单但效率低。

有利于CPU繁忙型作业，不利于I/O繁忙型作业。

（CPU繁忙型作业类似长作业，I/O繁忙型作业类似短作业）

#### 短作业优先调度算法（SJF）

#### 优先级调度算法

有剥夺式优先级调度算法和非剥夺式优先级调度算法。

优先级：

系统进程>用户进程

交互性进程>非交互型进程

I/O型进程>计算型进程（有利于让I/O设备尽早开始工作，进而提高系统的整体效率）

#### 高响应比优先调度算法

相应比R_P=(等待时间+要求服务时间)/要求服务时间

作业的响应比可以随着等待时间的增加而提高。



#### 时间片轮转调度算法

适用于分时系统，人机交互（保证每个作业能在一定时间内轮到）

先来先服务，仅能运行一个时间片，用完时间片后被释放，进入就绪状态。

#### 多级反馈队列调度算法

结合了时间片轮转和优先级调度。

实现思想：

1. 多个就绪队列。
2. 高优先级队列中，每个进程运行的时间片小。
3. 未完成则进入下一队列的末尾。
4. 高优先级队列为空时，才调度低优先级队列中的进程运行。

长作业不会出现长时间得不到处理的情况。



## 进程同步

### 基本概念

临界资源是一次只允许一个进程使用的资源。

**临界区是**并发进程访问共享变量段的**代码程序**。

临界资源的访问过程可以分为四个部分：

1. 进入区
2. 临界区
3. 退出区
4. 剩余区

同步机制要遵循的原则：

1. 空闲让进
2. 忙则等待
3. 有限等待
4. 让权等待

### 实现临界资源互斥的基本方法

#### 软件实现方法

1. 单标志法：只能轮流访问临界区，违反“空闲让进”
2. 双标志法先检查：可能同时进入临界区，违反“忙则等待”
3. 双标志法后检查：可能相互谦让，违反“空闲让进”和“有限等待”
4. Peterson's Algorithm：后“谦让”的进程失去优先权，但不能进入临界区的进程仍会占用CPU，违反“让权等待”（问题不大）

#### 硬件实现方法

1. 中断屏蔽技术：简单高效，只适用于内核进程，不适用于用户进程，不适用于多处理机
2. 硬件指令方法：有TestAndSet(Lock)（TLS）指令、Swap指令，简单，可适用于多处理机，但违反“让权等待”

### 信号量

信号量用来解决互斥与同步问题，它只能被两个**原语**wait(S)和single(S)访问，也可以记为P操作和V操作。（P是荷兰语中的proberen 尝试，V是荷兰语中的verhogen 提高）

1. 整形信号量，不满足“让权等待”
2. 记录型信号量，可以在wait(S)方法中主动阻塞，在signal(S)方法中唤醒阻塞的进程
3. 利用信号量实现同步，如果期望的消息不存在，信号量初始值为0，如果期望的消息存在，初始值不为0
4. 利用信号量实现互斥，信号量初始值为1，对不同资源要设置不同信号量

### 管程

管程解决了信号量机制编程麻烦、易出错的问题，类似面向对象编程思想中的封装。

管程可以实现进程的同步和异步。

基本特征：

1. 局部于管程的数据只能被局部于管程内的过程访问（类似用Javabean中用private修饰的成员变量）
2. 一个进程只有通过调用管程内的过程才能进入管程访问的共享数据（类似Javabean中用public修饰的方法）
3. 每次只允许一个进程在管程内执行某个内部过程（Java中可以用关键字synchronized修饰方法，同一时间段内只能被一个线程调用）

组成部分：

1. 局部管程的共享结构数据说明
2. 对该数据结构进行操作的一组过程
3. 对局部于管程的共享数据设置初始值的语句



管程中的signal操作的作用与信号量机制中的V操作不同，新海的基质中的V操作一定会改变信号量的值S=S+1，而管程中的signal操作是针对某个条件变量的，若不存在因该条件而阻塞的进程，则signal不会产生任何影响，若错在因该条件而阻塞的进程，则signal会唤醒阻塞队列队首进程。

若进程A执行x.wait()操作，则该进程会阻塞，并挂到条件变量x对应的阻塞队列上。

> 这两段还不太懂，是结合94页29题和47题得到的。



### 经典同步问题

#### 单生产者-单消费者问题

当缓冲区空时，消费者阻塞，生产者生产一个产品后，唤醒消费者

当缓冲区满时，生产者阻塞，消费者消费一个产品后，唤醒生产者

缓冲区是临界资源，各进程要互斥访问

实现互斥操作一行要在实现同步的P操作之后，否则会发生死锁。（要确定缓冲区能操作后再加锁，而且临界区要尽可能短）



#### 多生产者-多消费者问题

生产者1生成产品1，生产者2生产产品2，消费者1消费产品1，消费者2消费产品2，缓冲区容量为1

缓冲区没有产品1时，消费者1阻塞

缓冲区没有产品2时，消费者2阻塞

缓冲区满时，生产者阻塞，产品被消费后，唤醒生产者



对于缓冲区容量为1的问题，**有可能**可以省略互斥量mutex（如果来不及分析是否可以省略mutex，最好加上）

#### 吸烟者问题

其实是单生产者-多消费者问题，比较简单

#### 读者-写者问题

暂时没看

#### 哲学家进餐问题

暂时没看





## 死锁

### 概念

死锁：相互等待对方手里的资源，各进程都**阻塞**，无法推进。如果发生死锁，至少有两个进程死锁。

饥饿：长期得不到满足的资源（如处理机）而无法推进。发生饥饿的进程可能只有一个，饥饿的进程状态时阻塞或就绪。

死循环：进程一致跳不出循环，可能是错误，也可能是程序员故意设计的。

### 必要条件

以下四个必要条件缺一不可：

1. 互斥条件（哲学家的筷子、打印机是互斥的，内存、扬声器不是互斥的）
2. 不剥夺条件：资源只能主动释放
3. 请求和保持条件：进程至少保持了一个资源，同时又请求新的资源。
4. 循环等待条件：存在一种进程资源的循环等待链。

### 死锁的处理策略

#### 预防死锁

破坏死锁产生的四个必要条件之一：

1. 破坏互斥条件，这种方式可以认为是无法实现的。
2. 破坏不剥夺条件：剥夺资源。增加系统开销，降低吞吐量。
3. 破坏请求并保持条件：一次性分配进程所需的全部资源，或**主动释放资源**。严重浪费系统资源，还**可能导致饥饿**（一直从某个进程取出资源，该进程一直得不到满足）
4. 破坏循环等待条件：采用顺序资源分配法。浪费系统资源，并造成编程不便。

#### 避免死锁

银行家算法：进行资源分配前，先计算此次资源分配的安全性，如果导致系统进入不安全状态，就不分配资源。

不安全状态是发生死锁的**必要不充分**条件。

> 预防死锁，使死锁在任何条件下都不可能发生。
>
> 避免死锁，在可能发生死锁的情况下避免死锁发生。

#### 死锁的检测

资源分配图中，圆形表示进程，矩形内表示资源，矩形内的小圆表示该资源的数量。

简化资源分配图时，从及不阻塞又不孤点的进程开始。

发生死锁的充要条件是资源分配图不能完全简化。

简化后还连着边的进程是死进程。

#### 死锁的解除

1. 资源剥夺法：挂起死锁进程，并抢占资源。
2. 撤销进程法：撤销部分死锁进程并剥夺全部资源。
3. 进程回退法：要保持进程的历史信息，设置还原点。