# 第7章排序

##  概念

稳定性：如果相等的关键字在排序后次序不变，则称排序算法是稳定的。*稳定性并不能衡量算法的优劣。*

内部排序：在排序期间元素是全部放在内存中。内部排序算法在执行过程中通常要进行两部操作：比较和移动。

外部排序：排序期间元素无法全部同时存放在内存中，不许再内、外存中移动。

## 插入排序

在基本有序时速度较快 。

### 直接插入排序

时间复杂度：$$ O(n^2) $$

### 折半插入排序

将比较和移动分离。

比较次数比直接插入排序少。

时间复杂度：$$ O(n^2) $$

### 希尔排序

时间复杂度：$$ O(n^2) $$

所有间距为$$ d_1 $$的元素分在同一组中，组内完成直接插入排序后，取第二个步长$$ d_2<d_1 $$，重复此过程，直到$$ d_t=1 $$为止。

不稳定。



## 交换排序

### 冒泡排序

从后往前，逆序则交换。

最坏情况和平均时间复杂度都是$$ O(n^2) $$

### 快速排序

是对冒泡排序的一种改进。

将待排序表分为两个部分，使得第一部分所有元素**小于**pivot，第二部分所有元素**大于等于**pivot。

pivot选取列表中的第一个元素。

过程：从两端出发，将左边第一个比pivot大的元素与右边第一个比pivot小的元素交换次序。重复此过程。

空间复杂度：最坏情况为$$ O(n^2) $$，平均情况为$$ O(\log_2 n) $$

时间复杂度：$$ O(n^2) $$

不稳定。



每经过一趟排序，会有一个元素（枢轴）处于最终位置。

**每次的枢轴都把表等分为长度相近的两个子表时，速度是最快的。当表已经有序或逆序时，速度最慢。**



## 选择排序

### 简单选择排序

每次选择未排序的最小元素，与未排序的第一个元素交换。

不应该每次找到比未排序的第一个元素小的元素就交换。只需要在一次循环中把最小元素记录下来。

*我用的最多的其实是削弱版的简单选择排序。*



时间复杂度：$$ O(n^2) $$

比较次数始终为$$ n(n-1)/2 $$

不稳定。

### 堆排序

堆的定义：根节点大于等于或小于等于孩子结点。

调整：从右到左，从下到上

建堆时间：$$ O(n) $$

最好、最坏、平均时间复杂度：$$ O(n\log_2 n) $$

不稳定。



## 归并排序

空间复杂度：$$ O(n) $$

时间复杂度：$$ O(log_2 n) $$



## 基数排序

空间复杂度：$$ O(r) $$

时间复杂度：$$ O(d(n+r)) $$，与初始状态无关。

只能对整数排序。

稳定。



## 内部排序比较

| 排序法  | 最好情况      | 平均情况       | 最坏情况      | 是否稳定 | 额外空间              | 备注                                           |
| ------- | ------------- | -------------- | ------------- | -------- | --------------------- | ---------------------------------------------- |
| 插入    | $$ O(n) $$        | $$ O(n^2) $$       | $$ O(n^2) $$      | 是       | $$ O(1) $$                | 大部分已排好序时较好                           |
| 冒泡    | $$ O(n) $$        | $$ O(n^2) $$       | $$ O(n^2) $$      | 是       | $$ O(1) $$                | n较小时好                                      |
| 选择    | $$ O(n^2) $$      | $$ O(n^2) $$       | $$ O(n^2) $$      | 否       | $$ O(1) $$                | n较小时好                                      |
| 希尔    | $$ O(n) $$        | 约$$ O(n^{1.3}) $$ | $$ O(n^2) $$      | 否       | $$ O(1) $$                | 复杂度依赖于增长序列的函数，此数学问题尚未解决 |
| 快速    | $$ O(n\log_2n) $$ | $$ O(n\log_2n) $$  | $$ O(n^2) $$      | 否       | $$ O(\log_2n)\sim O(n) $$ | n较大时好                                      |
| 堆      | $$ O(n\log_2n) $$ | $$ O(n\log_2n) $$  | $$ O(n\log_2n) $$ | 否       | $$ O(1) $$                | n较大时好                                      |
| 2路归并 | $$ O(n\log_2n) $$ | $$ O(n\log_2n) $$  | $$ O(n\log_2n) $$ | 是       | $$ O(n) $$                | n较大时好                                      |
| 基数    | $$ O(d(n+r)) $$   | $$ O(d(n+r)) $$    | $$ O(d(n+r)) $$   | 是       | $$ O(r) $$                | B是真数（0~9），R是基数（个十百）              |

绝大多数内部排序只适用于顺序存储结构。

## 外部排序

外部排序通常采用归并排序方法。

增加归并路数可以减少归并次数，从而减少磁盘的I/O次数。

### 败者树

如果不用败者树，从$$ m $$个元素中选择关键字最小的记录需要比较$$ m-1 $$次，每趟$$ n $$个递归元素需要做$$ (n-1)(m-1) $$次比较。

如果用败者树，比较次数就是这棵完全二叉树的深度$$ \lceil\log_2 n\rceil $$，每趟$$ n $$个递归元素需要做$$ \lceil\log_2 n\rceil\cdot m $$次比较。

### 置换-选择排序

生成外部排序初始归并段。

在外部排序中，输入/输出缓冲区就是排序的内存工作区，做$$ m $$路平衡归并排序需要$$ m $$个输入缓冲区和1个输出缓冲区。

做$$ m $$路平衡归并排序，为实现输出/内部归并/输出的并行处理，需要设置$$ 2m $$个输入缓冲区和2个输出缓冲区。

### 最佳归并树

设计$$ m $$路归并的优化方案。

是将哈夫曼树推广到$$ m $$叉树的情形，记录数最多的最晚归并，缺额的归并段留到最后。