# 第6章查找

## 顺序查找

平均查找长度的计算：概率*当前长度



在一般线性表的顺序查找中，如果查找成功，平均查找长度为$$ \text{ASL}_\text{成功}=\frac{n+1}2 $$；如果查找失败，查找长度为$$ \text{ASL}_\text{失败}=n+1 $$

在有序表的顺序查找中，无论查找成功还是失败，平均查找长度都是$$ \text{ASL}=\frac{n+1}2 $$

顺序查找的缺点是当$$ n $$较大时，平均查找长度较大，效率低；优点是对存储没有要求，顺序存储或链式存储皆可。



## 折半查找（二分查找）

适用于有序表。要求顺序存储。

**查找过程对应的判定树是一棵二叉排序树。**

判定树也是一棵平衡二叉树。

查找过程对应的判定树中所有的左右子树结点数相差1或相等，同一判定树中取整规则需固定（只能左子树多结点多1或只能右子树结点数多1）。

折半查找成功时，平均查找长度为$$ \text{ASL}=\log_2(n+1)-1 $$，效率高于顺序查找。

时间复杂度为$$ O(\log_2 n) $$



## 分块查找

将查找表分成若干子块，块内元素可以无序，块之间要求有序。每个块的最大关键字小于下一个块中的所有关键字。再建立一个索引表，索引表中每个元素含有各块的最大关键字和第一个元素地址。

分块查找先在索引表中确定待查记录所在的块，再在块中使用顺序查找。

当块的数量$$ s=\sqrt n $$时，平均查询长度取最小值$$ \sqrt n+1 $$

## B树

### 特征

对于$$ m $$阶B树：

子树比关键字数量多1。

除根节点外所有非叶节点子树数量在$$ \lceil m/2 \rceil $$到$$ m $$之间。

若根节点不是终端结点，则树数量在2到$$ m $$之间。

叶结点在同一层。

### 查找

略。

### 插入

如果插入后关键字个数等于$$ m $$，必须对结点进行分裂。

分裂方法：将中间位置的元素插入到原结点的父结点中，父节点关键字也超过上限，继续分裂，直至分裂过程传到根结点导致B树高度增1。

### 删除

略。



## B+树

### 特征

与B树不同的特征：

结点的子树与关键字数量相等。

结点关键字数量限制与B数不同。

非叶结点仅起索引作用，叶结点包含全部关键字。

B+树支持顺序查找，而B树不能。

### 应用

数据库索引。

## 散列表

散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数。

任何设计出来的散列函数都不可能绝对地避免冲突。

**理想情况下**，对散列表查找地时间复杂度为$$ O(1) $$

### 构造

*散列函数的构造方法不用记。*

### 处理冲突

发生聚集的原因是解决冲突的方法选择不当。

#### 开放地址法

对于冲突，查找下一个空闲单元。

同义词在散列表中不一定相邻，中间可能有非同义词。

#### 拉链法（链地址法、链接法）

把同义词存储在一个线性链表中。

### 性能

散列表的填充因子$$ \alpha $$表示一个表的装满程度，即：

$$ \alpha=\frac{\text{表中记录数}n}{\text{散列表长度}m} $$

## 串

### 模式匹配

求字串在主串中的位置

### KMP算法

i指针不需要回溯，仅将字串向后滑动，滑动长度为最长相等前后缀长度。

#### next数组

next[0]=-1，next[1]=0

next[n]=字符串前n字符号的最长相等前后缀长度。

失配后下次匹配时时，j=next[j]

有时为了简洁，会将next数组整体+1

