# 第2章数据的表示和运算

## 进制转换

除基取余法

乘基取整法

## BCD码

BCD码是用二进制表示的十进制数，有8421码、余3码、2421码

余3码是在8421码的基础上+3

## ASCII码

范围是0-127

'0'为48

'A'为65

'a'为97

## 校验码

任意两个编码之间最少变化的二进制数，称为数据校验码的码距。对于码距不小于2的数据校验码，开始具有检错的能力。码距越大，检错、纠错的能力越强，而且检错能力总是大于等于纠错能力的。

### 奇偶校验码（重要）

缺点：不能检测出偶数位错误，不能确定出错的位置。

奇校验码：使整个校验码中1的个数为奇数（含校验位）。

偶校验码：使整个校验码中1的个数为偶数（含校验位）。

### 海明码

1. 确定海明码的位数。`$ n+k+1\leq2^k $`，`$ n $`为有效信息的位数，`$ k $`为校验位的位数，若要检2位错，则需要增加一个校验位，即`$ k+1 $`位
2. 校验位在`$ 2^{i-1} $`上，即1、2、4、8……将校验位插入到数据位中，构成海明码
3. 数据位由位号之和为数据位位号的校验位校验。
4. 校验位的值为它校验的所有数据位的值求异或。
5. 第`$ i $`个校验位与它校验的所有数据位的值求异或，为1则表示第`$ i $`个数据位出错

海明码纠错`$ d $`位，需要码距为`$ 2d+1 $`位的编码方案；检错`$ d $`为，则只需码距为`$ d+1 $`

### 循环冗余校验码

1. 信息码后面补0，个数为生成多项式位数-1
2. 信息码与生成多项式做模2除法，产生余数，余数的位数为生成多项式位数-1
3. 余数即为校验位，添加到信息为后面。
4. CRC码与生成多项式做模2除法，若余数为0，则码字无错，余数中为1的位是出错位。



## 定点数的表示

### 原码

最高位表示符号。

0有正负两种。

### 反码

正数反码与原码相同。

负数符号位不变，其他位取反。

0只有一种。

### 补码

正数补码与原码相同。

负数符号位不变，其他位取反，末位+1。（这里末位+1不会导致溢出，因为不可能出现所有位为1的情况）

0只有一种。

负数由补码求原码，可以先将符号位不变，其他位取反，然后末位+1（这种方式比先末位-1再取反要好，因为可能除符号位外全是0）

### 移码

移码=真值+偏置值，通常偏置值取`$ 2^n $`，在这种情况下，补码符号位取反，得到移码。

0的移码是100000...

移码保持了原有的大小顺序

在IEEE754标准中，偏置值是`$ 2^n-1 $`



## 存储

在C语言中，变量以补码的形式存储。

大端方式：先存储高位（靠前的是高位，这是正常思维方式）。

小端方式：先存储低位。

边界对齐：起始地址能被自身长度整除



## 定点数的运算

### 移位

#### 算术移位

符号位不移动。

> 如果不记得负数的移位规则，可以先转换为原码再移位。

正数：左移右移均添0

负数：原码左右移均添0；补码负数右移添1，左移添0

#### 逻辑移位

符号位也要移动。

正数负数左移右移均添0

#### 循环移位

左移将最高位移到最低位。

### 补码的加减

符号位运算时产生的进位要丢掉，结果的符号位由运算给出。

### 溢出的判别

用两个符号位时，正数符号位为00，负数符号位为11

用两个符号位时，运算结果相同则无溢出，不同则有溢出。

左边的符号位初始值为0

10为负溢出，01为正溢出

### 乘法（看不懂，背结论吧）

#### 原码一位乘法

符号位不参与运算

对于数值为`$ n $`位的数，累加次数是`$ n $`，移位次数是`$ n $`

#### 补码一位乘法

符号位参与运算

对于数值为`$ n $`位的数，累加次数是`$ n+1 $`，移位次数是`$ n $`

### 除法（同上）

#### 原码除法运算（不恢复余数法）

符号位不参与运算

若最终结果位负，需恢复余数

加减次数为`$ n+1 $`或`$ n+2 $`

#### 补码除数运算（加减交替法）

符号位参数运算

商末尾恒置1

加减次数为`$ n+1 $`

### 强制转换

相同字节数的强制转换，对应的每一位都保持不变。

向低字节转换，将高位字节部分截断，地位直接赋值。

向高字节转换，高位部分会扩展为原数字的符号位。

## 浮点数的表示

`$ N=r^E\cdot M $`

`$ r $`是基数，通常为2

`$ E $`是阶码

`$ M $`是尾数

### IEEE 754标准

阶码用**移码**表示，偏置值为127或1023，尾数用**原码**表示，尾数采用隐藏位省略小数点钱的1。

短浮点数：数符1位，阶码8位，尾数23位

长浮点数：数符1位，阶码11位，尾数52位

因为数符在前，所以尾数不用考虑正负。

## 浮点数的运算

### 对阶

将阶码小的尾数右移，阶码+1，直到两个数的阶码相等为止。

不能将阶码大的尾数左移。

### 规格化

当尾数的最高位与符号位不同时，即为规格化形式。

左规：尾数的最高位与符号位相同，需要将尾数左移，阶码-1。

右规：当尾数求和结果溢出时，需要将尾数右移（相当于除2），阶码+1。

### 强制转换

精度从小到大的转换没有损失。

浮点数向整数转换，会有精度损失和溢出。

### 溢出

运算结果超出尾数的表示范围不一定溢出，只有规格化后阶码超出所能表示的范围时才会发生溢出。

浮点数运算下溢，可以当作机器零来处理，不需要中断来处理；浮点数上溢，必须中断来做相应的处理。



## 算数逻辑单元（ALU）

运算器的功能由控制器决定，运算器处理的数据通来自存储器，处理结果通常送回存储器。

和表达式：`$ A_i\oplus B_i\oplus C_{i-1} $`

进位表达式：`$ C_i=A_iB_i+(A_i\oplus B_i)C_{i-1} $`

进位产生函数：`$ G_i=A_iB_i $`

进位传递函数`$ P_i=(A_i\oplus B_i) $`

并行加法器的最长运行时间主要由进位信号的传递时间决定。

并行加法器分为串行进位和并行进位。

并行进位不依赖低位进位输出`$ C_{i-1} $`，但随着加法器位数的增加，`$ C_i $`的逻辑表达式会变得很复杂。

并行进位方式通常采用 组内并行组间串行方式进位方式 或 组内并行组间串行进位方式。

74181是4位并行加法器，74182是先行进位芯片。
