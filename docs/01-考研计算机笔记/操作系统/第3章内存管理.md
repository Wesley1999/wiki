# 第3章内存管理

## 内存管理的概念

### 基本原理和要求

在虚拟内存管理中，地址变换机构将逻辑地址变换为物理地址，形成该逻辑地址的阶段是**链接**。

对主存储器的访问以字或字节为单位，例如在页式管理中，不仅要知道块号，还要知道页内偏移量。

逻辑地址的分配是按页为单位分配的，主存的分配即物理地址的分配是以内存（物理）块为单位分配的。



C语言中，二进制代码和常量存放在正文段，动态分配的存储区存放在数据**堆**段，临时使用的变量存放在数据**栈**段。



#### 装入方式

1. 绝对装入：编译时产生绝对地址
2. 静态重定位（可重定位装入）：在装入时完成地址变换，将相对地址变为绝对地址。必须分配进程要求的全部内存空间，作业不能在内存中移动，也不能再申请内存空间。只适用于**连续分配的固定分区方式**。
3. 动态重定位（动态运行时装入）：装入内存后的所有地址均为相对地址。需要设置一个重定位寄存器。可以动态申请内存，适用于。

整个系统重定位寄存器只需要一个，因为系统处理器在同一时刻只能执行一条指令或访问数据，只需在切换程序执行时重置寄存器内容即可。而且寄存器是很昂贵的硬件。

#### 内存保护

1. 使用一对上、下限寄存器。
2. 使用重定位寄存器（或基地址寄存器）和界地址寄存器（又称限长寄存器）。重定位寄存器存放最小的**物理地址**，界地址寄存器存放最大的**逻辑地址**。

### 覆盖与交换（用于扩充内存/节省主存空间）

#### 覆盖

将经常活跃的部分放在固定区，其余部分按调用关系分段。

固定区不会被覆盖。

对用户不透明，增加了用户编程的负担，仅用于早期OS。

可用于单一连续分配和固定分区分配。

#### 交换

通过内存调度（中级调度）实现，将阻塞、在内存中驻留时间较长的进程换到磁盘的对换区。

磁盘分为文件区和对换区，对换区是连续的，速度较快。

PCB常驻内存，不会被换出。

正在进行I/O操作的进程不能换出主存，否则进程的I/O数据区将被新换入的进程占用。

#### 虚拟内存

见下一节。

### 连续分配管理方式

使用分区的方式，操作系统实现起来代价小，不需要额外硬件和特定数据结构的支持。

#### 单一连续分配

只有一道程序，占整个内存空间。

无外部碎片，有内部碎片。

> 内部碎片：分配给某进程的内存区域中，存在没有备用上的部分。
>
> 外部碎片：内存中的某些空闲分区由于太小而难以利用。

#### 固定分区分配

将内存空间划分为固定大小的区域，每个进程只装入一道作业，一道作业只属于一个分区。

分区大小可以相等，也可以不等。

有内部碎片，无外部碎片。

很少用于现代操作系统。

可采用静态重定位。

#### 动态分区分配

不预先划分内存，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。

需要使用空闲分区表或空闲分区链来记录内存的使用情况。

要用紧凑技术解决外部碎片（把进程移到一起，得到一个更大的连续空闲空间）。

无内部碎片，有外部碎片。

动态分区分配策略算法有：首次适应、最佳适应、最坏适应、邻近适应。

### 非连续分配管理方式

#### 基本分页存储管理方式

##### 基本概念

把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。

进程中的块称为页（Page）或页面，内存中的块称为页框，又称页帧、内存块、物理块。

地址结构为：页号P-页内偏移量W。

**每个进程拥有一张页表**，页表记录每个进程所对应的物理块，一般放在内存中。

存取一个数据或指令需要**访存两次**，第一次时访问页表，确定所取数据或指令的物理地址，第二次是根据该物理地址存取数据或指令。

没有外部碎片，内部碎片很小。

页的大小的设计，要考虑进程的平均大小、页表占用长度等，一旦确定，所有的页面就是等长的，与内存外存大小、CPU地址结构无关。

缺点：不方便按照逻辑地址模块实现信息的保护和共享。

> 这里涉及很多计算，比较简单，但难以描述。

##### 具有快表的地址变换机构

快表是一种访问速度比内存快很多的高速缓冲存储器（Cache），用来存放当前访问的若干**页表**项。

若未命中，则要在读出页表项后将其存入快表。

快表根据时间和空间的局部性来设计，在计算机组成原理中已经学过。

##### 两级页表

两级页表是为了解决单级页表过长，不能存储在一个块（页框）中，需要存储在连续内存空间的问题。

添加的一级页表称为页目录表。

如果两级不够，还可以采用多级，各级页表的大小不能超过一个块（页帧）的大小。

> 俄罗斯套娃

导致的问题是访存次数增加。

#### 基本分段存储管理方式

按照用户进程中的自然段划分逻辑空间。

优点：很方便按照逻辑模块实现信息的保护和共享。

缺点：如果段过长，为其分配很大的连续地址空间会很不方便。另外，会产生外部碎片（与动态分为类似，不过小一些）。

地址结构为为：段号-段内地址。

每个段的长度是不一致的，需要检查是否越界。

不能被修改的代码称为**可重入**代码或纯代码，不属于临界资源，这样的代码和不能修改的数据可以共享。

无内部碎片，有外部碎片。

也可以用快表。





可重入程序就是通过共享来使用同一块存储空间的，或通过动态链接的方式将所需的程序映射到相关程序中去，其最大的优点是减少了对程序段的调入/调出，因此减少了对换数量。

共享程序段可能同时被多个程序使用，所以必须可重入编码，否则无法实现共享功能。

> 书上是这样写的，不知道啥意思。



#### 段页式管理方式

引入是为了满足：方便编程、分段共享、分段保护、动态增长、动态链接。（没有方便操作）

能有效提高内存利用率。

地址结构为：段号S-页号P-页内偏移量W

有内部碎片。

每个进程一张段表，每个段一张页表。

也可以用快表。

## 虚拟存储技术

### 基本概念

非虚拟存储器中，作业必须全部装入内存，且在运行过程中也一直驻留内存

虚拟存储器中，作业不必装入内存，在运行过程中也不用一直驻留内存

虚拟存储技术用于扩充内存。

虚拟内存最大容量由计算机地址结构决定。

虚拟内存实际容量=min{内外存容量之和, CPU寻址范围}

### 请求分页管理方式

页表项地址结构：页号-物理块号-状态位P-访问字段A-修改位M-外存地址

状态位又称合法位。

访问字段A记录本页在一段时间内被访问的次数。

修改位M标识该页调入内存后是否被修改过。



访问内存时，先查快表，如果在快表中，就修改访问位和修改位，并直接形成物理地址；

如果不在快表中，但在内存中，就修改快表，修改访问位和修改位，再形成物理地址；

如果不在快表中，也不在内存中，就会发生缺页中断，进程阻塞（因为I/O操作比较慢），从外存找到所缺的页，换入主存，**等待下一轮运行时从内存中读出**。在换入主存时，如果主存满，就要从主存选择一页换出，如果换出的页被修改过，就要将该页写回外存（类似计算机组成原理Cache写策略中的写回法）。

### 页面置换算法

| 名称                                                         | 规则                                                         | 优缺点                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 最佳置换算法（OPT，Optimal）                                 | 淘汰以后永远或长时间不使用的页面。                           | 最能最好，但只是理想，无法实现。                             |
| 先进先出页面算法（FIFO，First In Last Out）                  | 淘汰最先进入内存的页面。                                     | 实现简单，性能差，可能出现Belady异常（娘化异常？），随着物理块数增加而页故障数不减反增。 |
| 最近最久未使用算法/最近最少使用算法（两个最）（LRU，Least Recently Used） | 淘汰最近最久没有访问的页面。                                 | 性能较好，但需要硬件支持，开销大。                           |
| 时钟置换算法/最近未使用算法/最不经常使用算法（一个最）（CLOCK/NRU，Not Recently Used） | 循环扫描个页面，第一轮淘汰访问位=0的页面，并将扫描过的访问位改为0。若第一轮没选中，则进行第二轮，第二轮一定会选中。 | 实现简单，开销小，但未考虑页面是否被修改过                   |
| 改进型时钟置换算法（改进型CLOCK/NRU）                        | 若用(访问位, 修改位)的形式表述，则：<br />第一轮：淘汰(0, 0)<br />第二轮：淘汰(0, 1)，并将扫描过的页面访问位值为0<br />第三轮：淘汰(0, 0)<br />第四轮：淘汰(0, 1) | 开销小，性能也不错<br />在访问情况相同的条件下，优先淘汰未修改的页面 |

导致LRU算法实现起来耗费高的主要原因是**需要对所有的页进行排序**。

淘汰页面后，新的页面会使用被淘汰的页面的页框。

### 页面分配策略

#### 驻留集大小（和策略）

驻留集：给一个进程分配的物理页框的几何就是这个进程的驻留集。

采用虚存，驻留集的大小一般小于进程的总大小。

驻留集过大，导致多道程序并发量下降，资源利用率降低。

驻留集过小，导致缺页率高。



固定分配：驻留集大小不可变

可变分配：驻留集大小可变

局部置换：只能选择进程自己的空闲物理块进行置换

全局置换：系可以选择操作系统保持的空闲物理块，或任何进程保持的物理块进行置换



不存在固定分配全局置换，因为两者的进程数是否可变存在矛盾。

固定分配局部置换：不灵活，难以确定为每个进程分配的物理块数。

可变分配全局置换：主要缺页就分配新的物理块，导致系统的并发能力下降，被选中的进程缺页率增加。

可变分配局部置换：要根据缺页频率动态增减**该进**程的物理块。



#### 调入时机

预调页策略：一次调入若干相邻的页，可能效率高但可能大多数未被访问，主要用于进程的首次调入。

请求调页测率：每次调入一页，调入的页一定会被访问，需要较多的I/O开销，主要用于运行期间。

#### 从何处调入

系统拥有足够的对换区空间时，可以全部从对换区调入所需页面，以提高调页速度。

系统缺少足够的对换区空间时，不会修改的文件从文件区调入，不会被调出，可能被修改的换出到对换区。

UNIX方式：首次调入从文件区，再次调出调入从对换区。

### 抖动（颠簸）

频繁的页面调度行为称为抖动或颠簸，产生的主要原因是，某个进程频繁访问的页面数量高于可用的物理页帧数目（分配给该进程的物理块不够）。

页面置换算法不合理也是导致抖动的原因。

抖动的产生与磁盘交换区容量和速度无关，因此更换更好的硬盘无法解决抖动。

更换更快的CPU也不能解决抖动。

增大内存可以减少缺页率，从而解决抖动。

减少多道程序度数，可以减少主存中的进程，从而减少换入还出，从而解决抖动。

### 工作集

工作集是指在某段时间间隔内，进程要访问的页面集合。

操作系统可以根据检测工作及的大小来决定驻留集的大小。

驻留集大小不能小于工作集大小。

### 地址翻译

> 这是与计算机组成原理结合的知识点，408考纲没有直接写出此考点。