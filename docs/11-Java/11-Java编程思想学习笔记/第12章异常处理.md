# 第12章异常处理

1.  抛出异常时，可以在构造异常对象的时候传入一个字符串，作为异常信息。
2.  把try块放在一个while循环里，是一个处理异常的方式。
3.  自定义异常类通常继承Exception类。
4.  Exception类的常用方法：getMessage()、getLocalizedMessage()、toString()、printStackTrace()，每一个靠后的方法都是前面的超集，提供更详细的信息。
5.  getStackTrace()方法返回的是一个由栈轨迹中的元素所构成的数组，每个元素都是StackTraceElement对象，表示栈中的一帧。
6.  捕获到异常后，后续的catch块会被忽略，子类对象也可以匹配其父类的处理程序。
7.  catch语句中也可以直接抛出异常，或者抛出另一个异常。如果是直接抛出，printStackTrace()将显示原来异常抛出点的调用栈信息，如果要更新这个信息，可以使用e.fillInStackTrace()方法，这个方法返回一个Throwable对象。调用这个方法的地方将成为异常的新发生地。
8.  从Throwable继承而得到的类由两种，Error用来表示编译时错误和系统错误，一般不用关心，Exception是可以被抛出的基本类型，需要关心。
9.  RuntimeException是一种特殊的异常，这种异常属于错误，它们会自动被Java虚拟机抛出。RuntimeException及其子类的错误不需要手动抛出，但也可以手动抛出。
10.  无论异常是否被抛出，finally（**不是final**）子句总能被执行。这与直接写在try-catch-finally外面不同，如果异常没有捕获到，try-catch-finally后面的代码就不会执行。Java有垃圾回收机制，所以内存释放不再是问题，当要把除内存之外的资源恢复到它们的初始状态时，就要用到finally子句，这种需要请清理的资源包括：已经打开的文件、网络连接、数据库连接、屏幕上画的图形等。
11.  如果在方法的try语句中写了return语句，finally语句中的代码依然会在返回之后，返回值被获取之前执行，如果在finally语句中也有return语句，方法返回值以最后返回的值为准。
12.  前一个异常还没处理完就抛出下一个异常，这会导致前一异常信息丢失，这是Java不完善的地方，在C++中这是错误的。
13.  子类构造器不能捕获父类构造器抛出的异常。
14.  在构造其中抛出异常，需要格外小心。