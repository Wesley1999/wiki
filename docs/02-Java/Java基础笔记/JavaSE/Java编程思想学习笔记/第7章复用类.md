# 第7章复用类

1.  方法可以使用类的成员变量，参考JavaBean。
2.  为类创建main方法的技术可以使类的单元测试变得简单易行，而且在单元测试之后，也无需删除main方法，可以将其留待下次测试。
3.  为了继承，一般的规则是将所有的数据成员都指定为private，将所有的方法指定为public，特殊情况下才需要调整。
4.  父类的构造器中，必需首先调用父类的构造器。如果父类有无参构造器，可以省略，隐式调用；如果父类没有无参构造器，或者要调用有参的父类构造器，就要用关键字super显式地调用父类构造器，并且放在父类构造器的开头。之所以这么做，是因为**子类必须具有父类的全部属性和方法，如果不将父类初始化，子类调用父类方法时就可能会出错**。
5.  代理，就是在一个类中创建其他类的对象，在类的方法中用其他类的对象调用其他类的方法，这样就可以通过这个类的对象来调用另一个类的方法。
或者可以理解成间接地用一个类的对象调用另一个类的对象的方法。（com.wangshaogang.chapter06）

6.  注解@Override的作用是只允许重写，防止不小心重载。
7.  将父类的引用替换为父类的引用，这个动作称为向上转型。
方法参数为父类对象时，同样可以接受父类对象。
8.  继承并不是很常用，尽管它是面向的对象的重要特征。是否使用继承，需要考虑“我真的需要向上转型吗？”，如果是，那么继承才是必须的；如果不是，就要优先考虑组合和代理。
9.  final关键字可以使基本类型的数值恒定不变，可以使对象的引用恒定不变，但对象自身是可以被修改的。
10.  根据惯例，既是static又是final的域（即编译器常量）用大写字母表示，单词之间用下划线分隔。
11.  空白final是指被声明为final的时候没有给初始值的域。空白final必须在构造方法中初始化，空白final可以做到根据对象而有所不同，却又有恒定不变的特征。
12.  在方法中，用final修饰形参，可以防止基本类型的值或对象的引用被改变。
这一特征用于向匿名内部类传递数据。
13.  final修饰的方法在继承中不能被重写。会降低效率，尽量不要使用。
14.  private方法隐式地指定为final，不需要显式指定。
15.  private方法在父类中是不存在的，所以父类中即使有同名的方法，也不是重写，不会报错，但最好采用不同的名字。
16.  final类不能被继承，final类的所有方法隐式指定为是final的。
17.  执行顺序：
父类静态（仅第一次） --> 父类静态（仅第一次） --> 父类非静态 --> 父类构造 --> 父类非静态 --> 父类构造
18.  类加载完后才能创建对象，类的加载就是初始化静态成员变量（暂时的理解）。
19.  如果main方法所在的类继承的类有静态块，要先执行静态块。