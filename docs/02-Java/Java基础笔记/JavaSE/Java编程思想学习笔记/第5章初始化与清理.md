# 第5章初始化与清理

1.  构造器必须与类名完全相同，所以不像普通方法那样首字母小写。
2.  构造器没有返回值，它与返回值为空（void）不同。
3.  每个重载的方法都必需有一个独一无二的参数类型列表，虽然参数顺序不同也可以重载，但不推荐，因为这会使代码难以维护。
4.  如果调用一个方法给出的参数可以满足多个重载方法，那么编译器会尽可能地去选择较小的类型，例如Object，long，int中，参数为int的重载方法会被优先选择。
5.  不能以返回值区分重载方法。
6.  默认构造器是无参的，如果有自定义的有参构造器，默认的有参构造器就会失效。
7.  使用this关键字的三种情况：
        1.  （最常见）在setter方法中消除变量引用的歧义
        2.  将当前类实例作为参数传递给另一个对象的方法（返回当前对象）
        3.  在构造器中调用构造器（只能置于起始处且只能使用一次）

8.  除构造器外，其他任何方法都不能调用构造器。
9.  static方法就是没有this的方法，在static方法的内部不能调用非静态方法。
10.  在类中可以定义finalize()方法，一旦垃圾回收器准备好释放对象占用的存储空间，会先调用该方法，在下一次回收动作发生时，才会真正释放对象占用的内存。
finalize()方法不同于C++中的析构函数，调用该方法不一定会清理垃圾，垃圾回收只与内存有关，所以这个方法不该被过多使用。
Java中一切皆对象，不用的对象会被垃圾回收器自动清理，但如果在Java中调用非Java代码，就要在finalize()方法中调用其他语言的函数，例如C/C++的free()函数。
11.  Java会保证所有变量在使用前得到初始化。如果程序员没有在类中对变量进行初始化，编译器会给变量一个默认值；如果在类中定义对象的引用没有初始化，此引用会获得一个特殊值null；如果在方法中没有初始化，编译器会报错，因为采用默认值反而会掩盖这种错误。
12.  类中的方法和对象会在调用构造方法前被初始化，即使写在构造方法后面，初始化对象时对调用创建对象的构造方法。（P94）
13.  C++不能在定义类的成员变量的地方为其初始化。
14.  main方法中所在的类中，执行main方法前也会先初始化类的成员变量，即使写在main方法后面。
15.  无论创建多少个对象，静态数据都只占用一份存储区域。static关键字不能用于局部变量，因此它只能作用于域（只能写在类中，不能写在方法中）。
16.  静态成员变量只有在第一次创建类的对象，或者第一次访问静态数据时，才会初始化，并且只会初始化一次。
17.  静态成员变量在非静态成员变量之前初始化。
18.  静态代码块跟静态成员变量类似，只有在第一次创建类的对象，或者第一次访问静态数据时，才会执行。
19.  构造块直接在类中用{}定义，每一次创建对象时执行。这种语法支持匿名内部类，后续讲解。
20.  执行顺序：**静态代码->main()方法->构造块->构造方法**，同类代码块按书写顺序执行。
21.  定义数组，int\[\] i;和int i\[\];这两种方式的含义是相同的，前一种方式能更直接的表明“int型数组”。
编译器不允许指定数组的大小。
22.  关键字new不能创建单个基本类型，但可以创建数组。用new创建的数组可以指定大小，或者不指定大小直接赋值，赋值的时候最后一个逗号可有可无（这一特征有利于维护长列表）。
23.  main()方法可以有多个，可以接收字符串数组形式的参数。
24.  用一个数组的引用给另一个数组的引用赋值，实际上只是复制了引用，这通常不是想要的效果。（似乎只有单个基本类型变量的赋值不是这样吧）
25.  如果类中没有定义toString()方法，那么打印对象显示的是类名后面跟着@多个十六进制数。
26.  可变参数是Java SE5的新特征，可变参数只能作为最后一个参数，格式是(类型… 引用)。
27.  可变参数方法的重载容易出错，因为实参可能同时满足两个方法，包括重载一个可变参数前面跟着一个更小范围参数的情况。（参考P105）
28.  关键字enum（枚举）是Java SE5新特征，与class类似。
29.  枚举的实例都是常量，因此按照命名习惯他们都用大写字母表示，如果一个名字中有多个单词，则用下划线分隔。
30.  枚举会自动添加一些方法，有toString()、ordinal()等，也可以像类一个重写或自定义方法，要求写在enum实例序列后面。
31.  不能用关键字new创建枚举的实例，要使用枚举的值，可以用类似int的语句声明。
32.  switch语句是要在有限的可能值中进行选择，因此它与枚举是绝佳的组合。